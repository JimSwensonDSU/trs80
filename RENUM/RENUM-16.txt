==========================================================================
DECONSTRUCTION OF RENUM-16.CAS SYSTEM TAPE AND DISASSEMBLY OF PROGRAM CODE

DISASSEMBLED AND DOCUMENTED BY JIM SWENSON                  DECEMBER, 2022
==========================================================================


OVERVIEW OF BASIC PROGRAM STORAGE
=================================
TO UNDERSTAND THE DISASSEMBLY/COMMENTS BELOW, IT'S FIRST USEFUL TO UNDERSTAND
HOW A BASIC PROGRAM IS STORED IN MEMORY ON THE TRS-80 MODEL I LEVEL II

IN MEMORY, A SINGLE LINE OF A BASIC PROGRAM IS STORED AS FOLLOWS:

  2 BYTES: ADDRESS OF THE NEXT LINE
  2 BYTES: THE LINE NUMBER
  N BYTES: THE LINE ITSELF, WITH RESERVED WORDS REPLACED BY A SINGLE BYTE CODE.
           FOR EXAMPLE "PRINT" IS B2, "GOTO" IS 8D, ETC.
  1 BYTE:  00

FOLLOWING THE FINAL LINE, THERE WILL BE 2 BYTES IN MEMORY:
  2 BYTES: 00 00 (ADDRESS OF THE NEXT LINE)

POINTERS:
  16548 / 40A4H POINTS TO THE FIRST LINE OF THE PROGRAM IN MEMORY, WHICH WILL BE
                17129 (42E9H) BY DEFAULT.
  16633 / 40F9H WILL POINT 1 BYTE PAST THE END OF THE PROGRAM.

WITHIN THE LINE ITSELF (THE N BYTES MENTIONED ABOVE), LINE NUMBERS ARE STORED
AS ASCII.  FOR EXAMPLE "GOTO 100" WOULD BE STORED IN MEMORY AS "8D 20 31 30 30" IN HEX

WHITE SPACE IN A LINE IS ALSO STORED LITERALLY IN ASCII.

SAY YOUR BASIC PROGRAM IS THE FOLLOWING:

  10 PRINT "HELLO"
  20 GOTO 10

IN MEMORY IT WOULD BE STORED AS:

  42E9: F7 42 0A 00 B2 20 22 48 45 4C 4C 4F 22 00
  42F7: 00 43 14 00 8D 20 31 30 00
  4300: 00 00
  4302:



OVERVIEW OF HOW "RENUM" WORKS
=============================

  INPUT:
    PROMPT USER FOR OL# (THE STARTING LINE NUMBER FOR RENUMBERING)
    PROMPT USER FOR NL# (THE NEW LINE NUMBER FOR OL#)
    PROMPT USER FOR INC (HOW MUCH TO INCREMENT BY)

    ALL LINES FROM OL# TO THE END WILL BE RENUMBERED.
    DURING INPUT, ONLY BREAK, BACKSPACE, AND 0-9 ARE RECOGNIZED AS INPUT.
    HITTING BREAK STARTS THE RENUM PROGRAM OVER.

  VALIDATION:
    ENSURES THAT THE INPUT MAKES SENSE.  FOR EXAMPLE, THE
    MAXIMUM LINE NUMBER ALLOWED IN A BASIC PROGRAM IS 65529
    SO RENUM WILL CHECK TO SEE IF THAT WOULD BE EXCEEDED.
    IF THERE IS NO LINE NUMBER THAT IS >= OL# IN THE PROGRAM,
    THAT IS ALSO AN ERROR.
    IF THE INPUT IS DETERMINED TO BE INVALID, RENUM WILL PRINT
    AN "ILLEGAL FC" ERROR MESSAGE AND EXIT, RETURNING THE USER
    TO THE BASIC PROMPT.

  AFTER VALIDATION, RENUMBERING WILL TAKE PLACE IN TWO PASSES.

  PASS 1:
    IN THIS PASS, RENUM STEPS THROUGH THE BASIC PROGRAM FROM
    THE OL# TO THE END AND DETERMINES WHAT THE NEW LINE NUMBER
    WILL BE FOR EACH LINE, STARTING WITH NL#, THEN NL#+INC,
    THEN NL#+2*INC, ETC.
    THIS INFORMATION IS OVERWRITTEN IN MEMORY IN THE BASIC
    PROGRAM ITSELF FOR EACH LINE.  BYTES 1-2 WILL HOLD THE
    OLD LINE NUMBER.  BYTES 3-4 WILL HOLD THE NEW LINE NUMBER.

  PASS 2:
    THIS PASS DOES THE WORK OF REPLACING THE ASCII REPRESENTATION
    OF A LINE NUMBER WITHIN THE BASIC PROGRAM LINES THEMSELVES.
    RENUM WORKS FROM THE FIRST LINE OF THE PROGRAM LINE BY LINE
    UNTIL IT REACHES THE END OF THE PROGRAM.

    ONLY NUMBERS THAT ARE PART OF STATEMENTS FOR THE FOLLOWING
    RESERVED WORDS ARE REPLACED:

      GOTO
      GOSUB
      THEN
      ELSE
      ON N GOTO
      ON N GOSUB
      ON ERROR GOTO
      RESUME
      ERL

    IF DURING THE RENUMBERING A LINE NUMBER IS ENCOUNTERED THAT
    DOES NOT EXIST, RENUM WILL PRINT A MESSAGE "UL N IN M" WHERE
    N IS THE UNKNOWN LINE NUMBER AND M IS THE LINE IT WAS FOUND
    IN, AND CONTINUE WITH THE OPERATION.

    DURING THIS PASS, WHEN AN OLD LINE NUMBER IS REPLACED WITH
    ITS NEW LINE NUMBER, THERE COULD BE 3 DIFFERENT CASES:

    1. OLD AND NEW NUMBERS ARE SAME NUMBER OF DIGITS
       IN THIS CASE, THE NEW NUMBER CAN JUST BE WRITTEN
       DIRECTLY OVER THE OLD NUMBER.
    2. OLD NUMBER HAS MORE DIGITS THAN NEW NUMBER
       IN THIS CASE, THE BASIC PROGRAM WILL BE SQUEEZED THE
       APPROPRIATE NUMBER OF BYTES.
    3. OLD NUMBER HAS LESS DIGITS THAN NEW NUMBER
       IN THIS CASE, THE BASIC PROGRAM WILL BE EXPANDED THE
       APPROPRIATE NUMBER OF BYTES.

    THIS SQUEEZING/EXPANDING WILL TAKE PLACE FOR EVERY
    APPLICABLE LINE NUMBER ON EVERY LINE.



DECONSTRUCTION/DISASSEMBLY
==========================

NOTE THAT THIS IS AN ANALYSIS OF THE 16K VERSION OF THE RENUM
PROGRAM SPECIFICALLY.  THERE ARE 4K, 16K, 32K, AND 48K VERSIONS
AVAILABLE.

WHILE THE LOGIC SHOULD BE THE SAME AMONGST THESE, THE MACHINE CODE
WILL HAVE DIFFERENCES.  FOR EXAMPLE, THERE ARE MANY INSTANCES OF
JUMPS TO A FIXED ADDRESS, AND THESE NEED TO MATCH UP WITH WHERE
THE RENUM PROGRAM ITSELF IS LOADED IN MEMORY.


THE DESCRIPTION BELOW INCLUDES THE OVERHEAD BYTES FROM THE FILE:

  LEADER
  SYNC
  FILENAME HEADER
  FILE NAME
  DATA BLOCK OVERHEAD BYTES
    DATA HEADER
    COUNT BYTE
    LOAD ADDRESS
    CHECKSUM
  ENTRY HEADER
  ENTRY ADDRESS

THE CODE ITSELF FOR THE PROGRAM IS DISASSEMBLED AND COMMENTED.
THE LAST DATA BLOCK ALSO INCLUDES SOME STRING CONSTANTS, WHICH
ARE DOCUMENTED AT THE END OF THE FOURTH DATA BLOCK.

LITERALS IN THE DISASSEMBLY ARE SHOWN IN HEX.

THE RAW HEX DUMP IS INCLUDED AT THE END OF THIS FILE.

=====================================================================

00      		LEADER (200 BYTES OF 00)
A5			SYNC BYTE
55			FILENAME HEADER
52 45 4E 55 4D 20	FILE NAME (RENUM<SPACE>)

=====================================================================

3C			DATA HEADER
00			COUNT BYTE (00 = 256 BYTES)
4C 7C			LOAD ADDRESS (7C4C = 31820) <- NOTE MATCHES INSTRUCTIONS IN "RENUM" MANUAL


FIRST DATA BLOCK (256 BYTES)
SHOWING LOCATION IN MEMORY WHERE LOADED.

7C4C	31 FE 7F	LD	SP, 7FFE	; STACK = 7FFE

						;
						; USER INPUT
						;

						; 7C4F - 7CA0 PROMPTING FOR AND READING INPUT
						; FOR OL#, NL#, AND INC
7C4F	21 A1 7F	LD	HL, 7FA1	; "<CURON><CR>RENUM<CR>OL#="
7C52	06 0C		LD	B, 0C		; 12 CHARS
7C54	CD 32 7F	CALL	7F32		; PRINT THE <CURON><CR>RENUM<CR>OL#= PROMPT
7C57	CD C8 7E	CALL	7EC8		; READ INPUT INTO 7FCC-7FD1
7C5A	DD 21 C7 7F	LD	IX, 7FC7	; IX = FLAG BYTE (7FC7)
7C5E	DD CB 00 86	RES	0, (IX+00)	; SET BIT 0 TO 0 IN FLAG BYTE
7C62	AF		XOR	A		; A = 0
7C63	57		LD	D, A		;
7C64	5F		LD	E, A		; DE = 0 (DEFAULT FOR OL#)
7C65	B8		CP	B		; B IS NUM DIGITS ENTERED
7C66	21 CB 7F	LD	HL, 7FCB	; 1 BYTE BEFORE INPUT BUFFER
7C69	C4 07 7F	CALL	NZ, 7F07	; IF ANYTHING ENTERED SAVE TO DE
7C6C	ED 53 D4 7F	LD	(7FD4), DE	; SAVE VALUE OF OL# TO (7FD4)
7C70	21 AD 7F	LD	HL, 7FAD	; "NL#="
7C73	06 04		LD	B, 04		; 4 CHARS
7C75	CD 32 7F	CALL	7F32		; PRINT THE NL#= PROMPT
7C78	CD C8 7E	CALL	7EC8		; READ INPUT INTO 7FCC-7FD1
7C7B	AF		XOR	A		; A = 0
7C7C	11 0A 00	LD	DE, 000A	; DE = 10 (DEFAULT FOR NL#)
7C7F	B8		CP	B		; B IS NUM DIGITS ENTERED
7C80	21 CB 7F	LD	HL, 7FCB	; 1 BYTE BEFORE INPUT BUFFER
7C83	C4 07 7F	CALL	NZ, 7F07	; IF ANYTHING ENTERED SAVE TO DE
7C86	ED 53 CA 7F	LD	(7FCA), DE	; SAVE VALUE OF NL# TO (7FCA)
7C8A	21 B1 7F	LD	HL, 7FB1	; "INC="
7C8D	06 04		LD	B, 04		; 4 CHARS
7C8F	CD 32 7F	CALL	7F32		; PRINT THE INC= PROMPT
7C92	CD C8 7E	CALL	7EC8		; READ INPUT INTO 7FCC-7FD1
7C95	11 0A 00	LD	DE, 000A	; DE = 10 (DEFAULT FOR INC)
7C98	21 CB 7F	LD	HL, 7FCB	; 1 BYTE BEFORE INPUT BUFFER
7C9B	AF		XOR	A		; A = 0
7C9C	B8		CP	B		; B IS NUM DIGITS READ
7C9D	C4 07 7F	CALL	NZ, 7F07	; IF ANYTHING READ SAVE TO DE
7CA0	ED 53 D2 7F	LD	(7FD2), DE	; SAVE VALUE OF INC TO (7FD2)

						;
						; VALIDATION
						;

7CA4	2A E9 42	LD	HL, (42E9)	; 42E9 IS START OF USER RAM FOR PROGRAM STORAGE
7CA7	7C		LD	A, H		; WE ARE CHECKING ADDRESS OF NEXT LINE
7CA8	B5		OR	L		; OF PROGRAM HERE.  IF VALUE IS 00 00
7CA9	CA B7 7E	JP	Z, 7EB7		; THERE IS NO PROGRAM, SO JUMP TO 7EB7
7CAC	7A		LD	A, D		; DE HOLDS VALUE FOR INC
7CAD	B3		OR	E		; CHECKING TO SEE IF INC = 0
7CAE	CA BE 7E	JP	Z, 7EBE		; IF SO, JUMP TO 7EBE ERROR ROUTINE
7CB1	DD CB 00 46	BIT	0, (IX+00)	; WAS BIT 0 OF THE FLAG BYTE SET?
7CB5	C2 BE 7E	JP	NZ, 7EBE	; IF SO, JUMP TO 7EBE ERROR ROUTINE
7CB8	11 FA FF	LD	DE, FFFA	; DE = 65530
7CBB	CD 2C 1B	CALL	1B2C		; ROM ROUTINE 1B2C: SEARCH FOR MATCHING LINE ROUTINE
						; THIS SEARCHES THE PROGRAM FOR A LINE NUMBER.
						; INPUT:
						;  DE = LINE NUMBER TO SEARCH FOR
						; OUTPUT:
						;  BC = ADDRESS OF SMALLEST LINE NUMBER >= REQUESTED
						;  HL = ADDRESS OF THE NEXT LINE AFTER BC
						; FLAGS DESCRIBE RESULTS:
						;  C AND Z = FOUND THE EXACT LINE
						;  NC AND Z = NOT EXACT LINE, BUT THE LOWEST LINE AFTER
						;  NC AND NZ = DID NOT FIND AND REACHED END OF PGM
						; IN THIS CASE, SEARCHING FOR 65530 WILL NOT BE FOUND.
						; BC WILL END UP POINTING TO THE 00 00 AT THE END OF PGM.
7CBE	ED 43 C8 7F	LD	(7FC8), BC	; SAVE LOCATION OF LINE TO (7FC8)

7CC2	ED 5B D4 7F	LD	DE, (7FD4)	; DE = VALUE OF OL#
7CC6	CD 2C 1B	CALL	1B2C		; ROM ROUTINE 1B2C: SEARCH FOR MATCHINE LINE ROUTINE
7CC9	38 03		JR	C, 03		; JUMP TO 7CCE IF WE FOUND THE LINE
7CCB	CA BE 7E	JP	Z, 7EBE		; DID NOT FIND OL# OR ANY LINE > IT.  ERROR
7CCE	C5		PUSH	BC		; SAVE FOUND LINE ADDRESS

7CCF	ED 5B CA 7F	LD	DE, (7FCA)	; DE = VALUE OF NL#
7CD3	CD 2C 1B	CALL	1B2C		; ROM ROUTINE 1B2C: SEARCH FOR MATCHING LINE ROUTINE
7CD6	C5		PUSH	BC		; SAVE FOUND LINE ADDRESS
7CD7	E1		POP	HL		; HL = LOC OF NL#
7CD8	D1		POP	DE		; DE = LOC OF OL#
7CD9	DF		RST	18		; ROM ROUTINE 1C90: COMPARE DE:HL, SET C IF DE>HL, Z IF EQUAL
7CDA	DA BE 7E	JP	C, 7EBE		; IF DE > HL (LOC OL# > LOC NL#) ERROR
7CDD	EB		EX	DE, HL		: HL = LOC OF OL#, DE = LOC OF NL#
7CDE	E5		PUSH	HL		; SAVE LOC OF OL#
7CDF	ED 4B D2 7F	LD	BC, (7FD2)	; BC = INC
7CE3	ED 5B CA 7F	LD	DE, (7FCA)	; DE = NL#
7CE7	18 0E		JR	0E		; JUMP TO 7CF7

						; 7CE9 - 7CFA
						; HL = NEW LINE NUMBER OF CURRENT LINE.
						; DE = LOC OF NEXT LINE.
						; Z = SET IF NEXT LINE IS END OG PGM.
						; THIS BLOCK GOES FROM OL# TO THE END.  IT STARTS WITH NL#
						; AND ADDS INC FOR EACH ADDITIONAL LINE FOUND.  IT IS CHECKING
						; TO MAKE SURE WE DON'T EXCEED 65529, WHICH IS THE HIGHEST
						; ALLOWED LINE NUMBER IN BASIC
7CE9	09		ADD	HL, BC		: HL IS THE NEW LINE NUMBER OF CURRENT LINE.  ADD INC TO IT
7CEA	DA BD 7E	JP	C, 7EBD		; EXCEEDED 65535.  ERROR
7CED	EB		EX	DE, HL		; HL = LOC OF NEXT LINE, DE = NEW LINE NUMBER OF NEXT LINE.
7CEE	E5		PUSH	HL		; SAVE LOC OF NEXT LINE
7CEF	21 F9 FF	LD	HL, FFF9	; HL = 65529
7CF2	DF		RST	18		; ROM ROUTINE 1C90: COMPARE DE:HL, SET C IF DE>HL, Z IF EQUAL
7CF3	E1		POP	HL		; HL = LOC OF NEXT LINE
7CF4	DA BD 7E	JP	C, 7EBD		; IF NEW LINE NUMBER OF NEXT LINE IS > 65529, ERROR
7CF7	CD 28 7F	CALL	7F28		; FIND NEXT LINE AFTER HL
7CFA	20 ED		JR	NZ, ED		; JUMP TO 7CE9 IF THERE ARE MORE LINES


						;
						; AT THIS POINT WE ARE GOING TO START THE RENUMBERING.
						; THERE WILL BE NO MORE FATAL ERRORS.


						;
						; PASS 1
						;
						; FIRST PASS IS TO UPDATE ALL THE LINE NUMBERS
						; ON THE LINES THEMSELVES.  THE OLD LINE NUMBERS
						; FOR EACH LINE ARE SAVED IN THE FIRST TWO BYTES
						; OF EACH LINE.
						;

7CFC	D1		POP	DE		; DE = LOC OF OL#
7CFD	D5		PUSH	DE		; SAVE LOC OF OL#
7CFE	21 E9 42	LD	HL, 42E9	; 42E9 IS START OF USER RAM FOR PROGRAM STORAGE

						; 7D01 - 7D17
						; LOOPS THROUGH THE LINES UP UNTIL THE LINE
						; BEFORE OL#.  WE SAVE THE OLD LINE NUMBER IN THE SPOT
						; THAT NORMALLY HOLDS THE ADDRESS OF THE NEXT LINE.
						; I.E. THE FIRST 2 BYTES

7D01	DF		RST	18		; ROM ROUTINE 1C90: COMPARE DE:HL, SET C IF DE>HL, Z IF EQUAL
7D02	28 15		JR	Z, 15		; JUMP TO 7D19 IF FOUND OL#
7D04	E5		PUSH	HL		; SAVE CURRENT LINE LOC
7D05	FD E1		POP	IY		; IY = CURRENT LINE LOC
7D07	CD 28 7F	CALL	7F28		; FIND NEXT LINE AFTER 
7D0A	FD 7E 02	LD	A, (IY+02)	; \
7D0D	FD 77 00	LD	(IY+00), A	;  | SAVING OLD LINE NUMBER
7D10	FD 7E 03	LD	A, (IY+03)	;  | ON TOP OF ADDRESS
7D13	FD 77 01	LD	(IY+01),A	; /
7D16	EB		EX	DE, HL		; HL = LOC OF NEXT LINE
7D17	18 E8		JR	E8		; JUMP TO 7D01

7D19	ED 5B CA 7F	LD	DE, (7FCA)	; DE = NL#
7D1D	E1		POP	HL		; HL = LOC OF OL#

						; NOW WE LOOP THROUGH THE LINES THAT ARE GETTING
						; A NEW LINE NUMBER
7D1E	E5		PUSH	HL		; SAVE LOC OF CURRENT LINE
7D1F	FD E1		POP	IY		; IY = LOC OF CURRENT LINE
7D21	CD 28 7F	CALL	7F28		; FIND NEXT LINE AFTER
7D24	FD 7E 02	LD	A, (IY+02)	; \
7D27	FD 77 00	LD	(IY+00), A	;  | SAVING OLD LINE NUMBER
7D2A	FD 7E 03	LD	A, (IY+03)	;  | ON TOP OF ADDRESS
7D2D	FD 77 01	LD	(IY+01), A	; /
7D30	FD 75 02	LD	(IY+02), L	; \  AND WRITE IN THE NEW LINE NUMBER
7D33	FD 74 03	LD	(IY+03), H	; /
7D36	28 04		JR	Z, 04		; JUMP TO 7D3C IF THERE ARE NO MORE LINE
7D38	09		ADD	HL, BC		; ADD THE INC TO HL TO GET THE NEXT LINE NUMBER
7D39	EB		EX	DE, HL		; HL = LOC OF NEXT LINE, DE = NEW LINE NUMBER FOR NEXT LINE
7D3A	18 E2		JR	E2		; JUMP TO 7D1E

						;
						; AT THIS POINT ALL THE LINES OF THE PGM HAVE HAD THEIR
						; FIRST TWO BYTES CLOBBERED.  THE OLD LINE NUMBER IS
						; SAVE THERE NOW.  AND ALL THE LINES OF THE PGM HAVE HAD
						; THEIR NEW LINE NUMBERS WRITTEN IN.
						;
						; NOT TO WORRY, THERE IS A ROM ROUTINE THAT WILL
						; REPOPULATE ALL THE CORRECT ADDRESS OF NEXT LINE
						; VALUES. (ROM ROUTINE 1AFC)
						;


						;
						; PASS 2
						;
						; SECOND PASS IS TO UPDATE ALL THE LINE NUMBERS
						; WITHIN EACH PROGRAM STATEMENT.  THESE ARE STORED
						; IN ASCII FOR EACH PROGRAM LINE.
						;
						; AS THE LINE NUMBERS ARE REPLACED, THE PROGRAM
						; ITSELF COULD EXPAND OR CONTRACT IN SIZE.
						; (7FC8) KEEPS TRACK OF THE END OF THE PROGRAM.

7D3C	21 E8 42	LD	HL, 42E8	; 42E8 IS 1 BYTE BEFORE START OF USER RAM FOR PROGRAM STORAGE

						; 7D3F IS THE TOP OF LOOP FOR PASS 2
7D3F	ED 5B C8 7F	LD	DE, (7FC8)	; DE = CURRENT END OF PGM - THE 00 00
7D43	1B		DEC	DE		; DE = LAST BYTE IN LAST LINE - THE 00
7D44	DF		RST	18		; ROM ROUTINE 1C90: COMPARE DE:HL, SET C IF DE>HL, Z IF EQUAL
7D45	CA A3 7E	JP	Z, 7EA3		; JUMP TO 7EA3 IF WE HAVE REACHED END OF PGM
7D48	23		INC	HL
7D49	23		INC	HL
7D4A	23		INC	HL		; HL POINTING TO LSB OF NEW LINE NUMBER
7D4B	7E		LD	A, (HL)		; A = LSB OF NEW LINE NUMBER

42			CHECKSUM FOR FIRST DATA BLOCK

=====================================================================

3C			DATA HEADER
00			COUNT BYTE (00 = 256 BYTES)
4C 7D			LOAD ADDRESS (7D4C = 32076)


SECOND DATA BLOCK (256 BYTES)
SHOWING LOCATION IN MEMORY WHERE LOADED.

7D4C	32 CA 7F	LD	(7FCA), A
7D4F	23		INC	HL		; HL POINTING TO MSB OF NEW LINE NUMBER
7D50	7E		LD	A, (HL)		; A = MSB OF NEW LINE NUMBER
7D51	32 CB 7F	LD	(7FCB), A	; NOW (7FCA) HOLDS CURRENT LINE'S NEW LINE NUMBER
7D54	DD CB 00 8E	RES	1,(IX+00)	; SET BIT 1 = 0 IN FLAG BYTE (BIT 1 = 1 INDICATES SKIP 0S)
7D58	D7		RST	10		; ROM ROUTINE 1D78: LOAD AND EXAMINE NEXT CHAR AFTER HL LOC
						; SEE BELOW FOR AN IN DEPTH EXPLANATION OF THIS ROUTINE
7D59	38 FD		JR	C, FD		; JUMP TO 7D58 IF A NUMBER 0 - 9 (READ AGAIN)
7D5B	20 06		JR	NZ, 06		; JUMP TO 7D63 IF NOT A : OR 00 (END OF LINE)
7D5D	FE 00		CP	00		; 00 IS END OF LINE
7D5F	28 DE		JR	Z, DE		; JUMP TO 7D3F IF REACHED END OF THIS LINE
7D61	18 F1		JR	F1		; JUMP TO 7D54 (WE READ A : SO CONTINUE PROCESSING)

7D63	FE 8D		CP	8D		; 8D IS GOTO                \
7D65	28 22		JR	Z, 22		; JUMP TO 7D89 FOR GOTO      |
7D67	FE 91		CP	91		; 91 IS GOSUB                | RESERVED WORDS THAT
7D69	28 1E		JR	Z, 1E		; JUMP TO 7D89 FOR GOSUB     | COULD BE FOLLOWED
7D6B	FE C2		CP	C2		; C2 IS ERL                  | BY A LINE NUMBER.
7D6D	CA 84 7E	JP	Z, 7E84		; JUMP TO 7E84 FOR ERL       |
7D70	FE 9F		CP	9F		; 9F IS RESUM                | GOTO, GOSUB, ERL,
7D72	CA 6D 7E	JP	Z, 7E6D		; JUMP TO 7E6D FOR RESUM     | RESUM, THEN, ELSE,
7D75	FE CA		CP	CA		; CA IS THEN                 | ERROR
7D77	CA 71 7E	JP	Z, 7E71		; JUMP TO 7E71 FOR THEN      |
7D7A	FE 95		CP	95		; 95 IS ELSE                 |
7D7C	CA 71 7E	JP	Z, 7E71		; JUMP TO 7E71 FOR ELSE      |
7D7F	FE 9E		CP	9E		; 9E IS ERROR                |
7D81	20 D5		JR	NZ, D5		; JUMP TO 7D58 UNLESS ERROR /
7D83	DD CB 00 CE	SET	1,(IX+00)	; SET BIT 1 = 1 IN FLAG BYTE SO WE IGNORE 0S FOR ERROR
7D87	18 CF		JR	CF		; JUMP TO 7D58 (READ AGAIN)

---------------------------------------------------------------------
						; ** ROUTINE: GOTO AND GOSUB **
7D89	D7		RST	10		; ROM ROUTINE 1D78: LOAD AND EXAMINE NEXT CHAR AFTER HL LOC
7D8A	38 0B		JR	C, 0B		; JUMP TO 7D97 IF HAVE A DIGIT
7D8C	FE 00		CP	00		; 00 IS END OF LINE
7D8E	28 AF		JR	Z, AF		; JUMP TO 7D3F (END OF LINE SO LOOP TO THE NEXT LINE)
7D90	FE 2C		CP	2C		; 2C IS A COMMA
7D92	28 F5		JR	Z, F5		; JUMP TO 7D89 (STAY IN GOTO/GOSUB PROCESSING FOR COMMA)
						; FOR EXAMPLE, HANDLING "ON GOTO" AND "ON GOSUB"
7D94	2B		DEC	HL		; REWIND HL 1 BYTE
7D95	18 BD		JR	BD		; JUMP TO 7D54 (DONE WITH GOTO/GOSUB. CONTINUE PROCESSING)
						; THE REST OF LINE)
7D97	FD 21 89 7D	LD	IY, 7D89	; WILL RETURN TO GOTO/GOSUB ROUTINE AFTER NUMBER UPDATED
						; IN CASE THERE ARE MORE NUMBERS.  FALL INTO REPLACE NEXT:
---------------------------------------------------------------------
						; ** ROUTINE: REPLACE OLD NUMBER WITH NEW NUMBER **
						; 7D9B - THIS IS THE ROUTINE THAT UPDATES ONE NUMBER
						; IN ONE LINE OF A BASIC PROGRAM FROM THE OLD NUMBER
						; TO THE NEW NUMBER.
						;
						; INPUTS:
						;   HL = LOC OF THE NUMBER IN THE LINE
						;   IY = LOCATION TO JUMP BACK TO WHEN DONE
						;   BIT 1 IN FLAG BYTE (7FC7) - IF SET TO 1, IGNORE
						;     NUMBER IF IT IS 0S.  IE DO NOT TRY TO REPLACE
						;
						; FOR BREVITY "N" WILL REFER TO THE OLD LINE NUMBER.
						;
						; GIVEN N, THE ROUTINE LOOPS THROUGH ALL THE LINES
						; OF THE PGM LOOKING FOR N IN THE FIRST 2 BYTES.
						; THEN IT CAN GET THE NEW N FROM BYTES 3-4 OF THAT LOCATED
						; LINE. RECALL THAT PASS 1 WROTE THE OLD LINE NUMBERS TO
						; BYTES 1-2 AND THE NEW LINE NUMBERS TO BYYES 3-4 FOR
						; ALL LINES.
						;
7D9B	E5		PUSH	HL		; SAVE LOC IN LINE (FIRST DIGIT OF NUMBER) TO STACK
7D9C	2B		DEC	HL		; REWIND 1 BYTE
7D9D	DD CB 00 86	RES	0,(IX+00)	; SET BIT 0 = 0 IN FLAG BYTE
7DA1	CD 07 7F	CALL	7F07		; DE = PARSED NUMBER FROM THE LINE = N
7DA4	E5		PUSH	HL		; SAVE LOC IN LINE (1 BYTE AFTER NUMBER) TO STACK
7DA5	DD CB 00 46	BIT	0,(IX+00)	; WAS NUMBER TOO LARGE?
7DA9	C2 45 7E	JP	NZ, 7E45	; UNDEFINED LINE ERROR, WHICH EVENTUALLY JUMPS TO (IY)
7DAC	DD CB 00 4E	BIT	1,(IX+00)	; CHECK BIT 1 OF FLAG BYTE
7DB0	28 05		JR	Z, 05		; JUMP TO 7DB7 IF NOT SET (JUMPING OVER THE DE=0 CHECK)
7DB2	7A		LD	A,D
7DB3	B3		OR	E		; CHECKING IF DE = 0
7DB4	CA 68 7E	JP	Z,7E68		; DONE SINCE DE = 0.  JUMPING INTO LAST PART OF THE UNDEFINED
						; LINE ERROR ROUTINE WHICH RESTORES HL AND CLEARS STACK

7DB7	21 E7 42	LD	HL,42E7		; 42E7 IS 2 BYTES BEFORE START OF USER RAM FOR PROGRAM STORAGE
						; 42E8 *SHOULD* BE A 00.  42E9 IS THE START OF THE BASIC PGM

						; ** 7DBA IS THE TOP OF THE MAIN LOOP THROUGH ALL PGM LINES **
7DBA	D7		RST	10		; ROM ROUTINE 1D78: LOAD AND EXAMINE NEXT CHAR AFTER HL LOC
7DBB	FE 00		CP	00		; 00 IS END OF LINE (LOOKING FOR THE END OF LINE)
7DBD	20 FB		JR	NZ,FB		; JUMP TO 7DBA TO READ AGAIN IF NOT AT 00 YET

						; HL POINTS TO END OF CURRENT LINE NOW (THE 00) OR 1 BYTE BEFORE
						; START OF PGM IF WE'RE AT THE START.
7DBF	D5		PUSH	DE		; SAVE N TO STACK
7DC0	ED 5B C8 7F	LD	DE,(7FC8)	; DE = END OF PGM = LOC OF THE 00 00
7DC4	1B		DEC	DE		; DE = END OF LAST LINE OF THE PGM = LOC OF 00
7DC5	DF		RST	18		; ROM ROUTINE 1C90: COMPARE DE:HL, SET C IF DE>HL, Z IF EQUAL
7DC6	D1		POP	DE		; DE = N
7DC7	CA 45 7E	JP	Z,7E45		; UNDEFINED LINE.  WE SEARCHED ENTIRE PGM AND DID NOT FIND N.
7DCA	23		INC	HL		; HL = FIRST BYTE OF LINE
7DCB	7E		LD	A,(HL)		; A = LSB OF OLD LINE NUMBER
7DCC	23		INC	HL		; HL POINTS TO MSB OF OLD LINE NUMBER
7DCD	E5		PUSH	HL		; SAVE HL TO STACK
7DCE	66		LD	H,(HL)
7DCF	6F		LD	L,A		; HL = OLD LINE NUMBER
7DD0	DF		RST	18		; ROM ROUTINE 1C90: COMPARE DE:HL, SET C IF DE>HL, Z IF EQUAL
						; (CHECKING TO SEE IF WE FOUND N.  Z FLAG IF SO)
7DD1	E1		POP	HL		; HL POINTS TO MSB OF OLD LINE NUMBER
7DD2	23		INC	HL
7DD3	23		INC	HL		; HL POINTS TO MSB OF NEW LINE NUMBER
7DD4	20 E4		JR	NZ,E4		; JUMP TO 7DBA (THIS ISN'T THE LINE WE'RE LOOKING FOR.  LOOP AGAIN)
7DD6	56		LD	D,(HL)		; FOUND IT!  D = MSB OF NEW LINE NUMBER
7DD7	2B		DEC	HL		; HL = LOC OF LSB OF NEW LINE NUMBER
7DD8	5E		LD	E,(HL)		; DE = NEW LINE NUMBER!
7DD9	CD 4F 7F	CALL	7F4F		; CONVERT DE TO DECIMAL AND STORE IN 7FCF-7FD3
7DDC	E1		POP	HL		; HL = LOC AFTER N
7DDD	C1		POP	BC		; BC = LOC OF N
7DDE	C5		PUSH	BC		; SAVE LOC OF N BACK TO STACK
7DDF	E5		PUSH	HL		; SAVE LOC AFTER N BACK TO STACK
7DE0	AF		XOR	A		; A = 0
7DE1	ED 42		SBC	HL,BC		; HL = HL - BC = NUMBER OF DIGITS IN N
7DE3	CD 86 7F	CALL	7F86		; DE = LOC OF FIRST NON 0 DIGIT IN DECIMAL VAL OF NEW LINE NUMBER
						; B = NUMBER OF DIGITS IN THE NEW LINE NUMBER W/O LEADING 0S
7DE6	7D		LD	A,L		; A = NUMBER OF DIGITS IN N (THIS IS HOW MANY WE ARE REPLACING)
7DE7	90		SUB	B		; A = A - B.  WE ARE COMPARING A AND B HERE

						; 3 CASES: 
7DE8	38 34		JR	C,34		; MORE # DIGITS IN NEW NUMBER THAN OLD NUMBER N  JUMP TO 7E1E
7DEA	28 1E		JR	Z,1E		; SAME # DIGITS IN NEW NUMBER AND OLD NUMBER N   JUMP TO 7E0A
7DEC	E1		POP	HL		; LESS # DIGITS IN NEW NUMBER THAN OLD NUMBER N  HL = LOC AFTER N
7DED	E5		PUSH	HL		; SAVE LOC AFTER N BACK TO STACK
7DEE	4F		LD	C,A		; C = NUMBER OF DIGITS NO LONGER NEEDED
7DEF	AF		XOR	A		; A = 0
7DF0	47		LD	B,A		; BC = NUMBER OF DIGITS NO LONGER NEEDED
7DF1	ED 42		SBC	HL,BC		; HL = LOC WITHIN N TO START COPYING TO
7DF3	EB		EX	DE,HL		; DE = LOC WITHIN N TO START COPYING TO
7DF4	E1		POP	HL		; HL = LOC AFTER N
7DF5	ED 53 D4 7F	LD	(7FD4),DE	; SAVE LOC TO PICK UP AT AFTER NEW N IS IN PLACE

						; NOW WE LOOP, COPYING THE ENTIRE REST OF THE PGM BYTE BY BYTE
						; ON TOP OF THE LOC WITHIN N.  SINCE NEW LINE NUMBER HAS LESS
						; DIGITS THAT OLD, WE'RE COLLAPSING THE PGM BY THE DIFFERENCE.
						; FOR EXAMPLE IF THE LINE WAS:
						;   PRINT "HELLO" : GOSUB 1234 : PRINT "BYE"
						; AND THE NEW LINE NUMBER FOR 1234 WAS 20, THEN THE RESULT IS
						;   PRINT "HELLO" : GOSUB 12 : PRINT "BYE"
						; WE'RE NOT WRITING THE NEW LINE NUMBER IN JUST YET.  WE ARE
						; JUST ADJUSTING THINGS IN MEMORY.

7DF9	ED A0		LDI			; COPY 1 BYTE FROM (HL) TO (DE).  HL AND DE ARE INCREMENTED 1.
						; AND BC IS DECREMENTED 1, BUT BC DOESN'T MATTER AT THIS POINT
7DFB	D5		PUSH	DE		; SAVE DE
7DFC	ED 5B C8 7F	LD	DE,(7FC8)	; DE = END OF PGM = LOC OF 00 00
7E00	DF		RST	18		; ROM ROUTINE 1C90: COMPARE DE:HL, SET C IF DE>HL, Z IF EQUAL
7E01	D1		POP	DE		; RESTORE DE
7E02	20 F5		JR	NZ,F5		; JUMP TO 7DF9 (KEEP COPYING SINCE WE HAVEN'T MOVED WHOLE PGM YET)

7E04	ED 53 C8 7F	LD	(7FC8),DE	; SAVE THE NEW END OF PGM TO (7FC8)
7E08	18 04		JR	04		; JUMP TO 7E0E

						; WE LAND AT 7E0A IF NUMBER OF DIGITS IN N AND NEW LINE NUMBER ARE =
7E0A	E1		POP	HL		; HL = LOC AFTER N
7E0B	22 D4 7F	LD	(7FD4),HL	; SAVE LOC TO PICK UP AT AFTER NEW N IS IN PLACE

						; 7E0E
						; AT THIS POINT THE PGM HAS BEEN ADJUST IN MEMORY, AND WE POINT
						; HL TO THE LOC OF N AND WRITE THE NEW LINE NUMBER INTO PLACE.
7E0E	E1		POP	HL		; HL = LOC ON N
7E0F	CD 86 7F	CALL	7F86		; DE = LOC OF FIRST NON 0 DIGIT IN DECIMAL VAL OF THE NEW LINE NUMBER
						; B = NUMBER OF DIGITS IN THE NEW LINE NUMBER W/O LEADING 0S
7E12	1A		LD	A,(DE)		; A = ASCII DIGIT
7E13	77		LD	(HL),A		; WRITE IT TO PGM
7E14	13		INC	DE		; ADVANCE HL AND DE
7E15	23		INC	HL
7E16	10 FA		DJNZ	FA		; JUMP TO 7E12 (LOOP FOR B MANY BYTES)

7E18	2A D4 7F	LD	HL,(7FD4)	; HL = LOC TO PICK UP NOW THAT WE'RE DONE REPLACING LINE NUMBER
7E1B	2B		DEC	HL		; REWIND 1 BYTE
7E1C	FD E9		JP	(IY)		; RETURN TO APPROPRIATE LOCATION.  WOO!

						; 7E1E
						; THIS HANDLES THE CASE WHERE THE NEW LINE NUMBER HAS MORE
						; DIGITS THAN THE OLD LINE NUMBER.  WE WILL NEED TO SHIFT
						; THE PGM FORWARD IN MEMORY A NUMBER OF BYTES = THE DIFFERENCE.
						; RECALL THAT A WILL COME IN WITH THAT DIFFERENCE AMOUNT.
7E1E	ED 44		NEG			; A IS NEGATIVE. A = A * -1
7E20	06 00		LD	B,0		; B = 0
7E22	4F		LD	C,A		; BC = HOW MANY DIGITS LONGER IS NEW LINE NUMBER THAN N
7E23	2A C8 7F	LD	HL,(7FC8)	; HL = END OF PGM
7E26	E5		PUSH	HL		; SAVE END OF PGM TO STACK
7E27	D1		POP	DE		; DE = END OF PGM
7E28	09		ADD	HL,BC		; ADD EXTRA NUMBER OF DIGITS TO GET NEW END OF PGM
7E29	22 C8 7F	LD	(7FC8),HL	; SAVE THE NEW END OF PGM TO (7FC8)
7E2C	EB		EX	DE,HL		; HL = OLD END OF PGM, DE = NEW END OF PGM
7E2D	C1		POP	BC		; BC = LOC AFTER N
7E2E	0B		DEC	BC		; BC = LOC OF LAST DIGIT IN N
7E2F	ED 43 D4 7F	LD	(7FD4),BC	; SAVE LOC OF LAST DIGIT IN N TO (7FD4)

7E33	ED A8		LDD			; COPY 1 BYTE FROM (HL) TO (DE) AND DECREMENT BOTH.  ALSO
						; DECREMENTS BC, WHICH DOESN'T MATTER.
7E35	D5		PUSH	DE		; SAVE DE TO STACK
7E36	ED 5B D4 7F	LD	DE,(7FD4)	; DE = LOC OF LAST DIGIT OF N
7E3A	DF		RST	18		; ROM ROUTINE 1C90: COMPARE DE:HL, SET C IF DE>HL, Z IF EQUAL
7E3B	D1		POP	DE		; RESTORE DE
7E3C	20 F5		JR	NZ,F5		; JUMP TO 7E33 (LOOP UNTIL WE REACH LOC OF LAST DIGIT OF N)
						; SAME APPROACH AS USING LDI AS BEFORE, EXCEPT WE ARE
						; MOVING BACKWARDS IN MEMORY INSTEAD OF FORWARDS SINCE
						; WE ARE OPENING A GAP RATHER THAN CLOSING IT THIS TIME.
7E3E	13		INC	DE		; DE = 1 BYTE PAST LOC OF LAST DIGIT OF N
7E3F	ED 53 D4 7F	LD	(7FD4),DE	; SAVE LOC TO PICK UP AT AFTER NEW N IS IN PLACE
7E43	18 C9		JR	C9		; JUMP TO 7E0E TO GET NEW N COPIED INTO PLACE!
---------------------------------------------------------------------
7E45	21 C0 7F	LD	HL,7FC0		; ** ROUTINE: UNDEFINED LINE ** "UL<SPACE>"
7E48	06 03		LD	B,03		; 3 CHARS
7E4A	CD 32 7F	CALL	7F32		; PRINT THE ERROR MSG
						; NOTE 7F IS FROM THE FIRST BYTE OF BLOCK 3

7B			CHECKSUM FOR SECOND DATA BLOCK

=====================================================================

3C			DATA HEADER
00			COUNT BYTE (00 = 256 BYTES)
4C 7E			LOAD ADDRESS (7E4C = 32332)


THIRD DATA BLOCK (256 BYTES)
SHOWING LOCATION IN MEMORY WHERE LOADED.

7F			FIRST BYTE OF THIRD BLOCK, PUT INTO CALL COMMAND ABOVE

7E4D	DD CB 00 46	BIT	0,(IX+00)	; BIT 0 IN FLAG BYTE NOT SET
7E51	CC 96 7F	CALL	Z,7F96		; PRINT THE VALUE OF DE (NUMBER N FROM THE LINE)
7E54	21 C3 7F	LD	HL,7FC3		; "<SPACE>IN<SPACE>""
7E57	06 04		LD	B,04		; 4 CHARS
7E59	CD 32 7F	CALL	7F32		; PRINT THE MSG
7E5C	ED 5B CA 7F	LD	DE,(7FCA)	; DE = THE NEW LINE NUMBER
7E60	CD 96 7F	CALL	7F96		; PRINT THE VALUE OF DE
7E63	3E 0D		LD	A,0D		; A = <CR>
7E65	CD 45 7F	CALL	7F45		; PRINT CHAR IN A
7E68	E1		POP	HL		; HL = LOC AFTER NUMBER N (THE N=0/DE=0 CASE JUMPS HERE)
7E69	2B		DEC	HL		; REWIND 1 BYTE
7E6A	C1		POP	BC		; BC = LOC OF NUMBER N (JUST CLEARING FROM STACK)
7E6B	FD E9		JP	(IY)		; RETURN TO APPROPRIATE LOCATION
---------------------------------------------------------------------
						; ** ROUTINE: RESUM **
7E6D	DD CB 00 CE	SET	1,(IX+0)	; RESUM IGNORES 0S
						; ** ROUTINE: THEN/ELSE **
7E71	D7		RST	10		; ROM ROUTINE 1D78: LOAD AND EXAMINE NEXT CHAR AFTER HL LOC
7E72	38 09		JR	C,09		; JUMP TO 7E7D (WE HAVE A DIGIT)
7E74	FE 00		CP	00		; 00 IS END OF LINE
7E76	CA 3F 7D	JP	Z,7D3F		; JUMP TO 7D3F (END OF LINE SO LOOP TO THE NEXT LINE)
7E79	2B		DEC	HL		; REWIND HL 1 BYTE
7E7A	C3 54 7D	JP	7D54		; JUMP TO 7D54 (NO DIGIT SO DONE WITH RESUM/THEN/ELSE.
						; CONTINUE PROCESSING)
7E7D	FD 21 54 7D	LD	IY,7D54		; WILL RETURN TO CONTINUE PROCESSING WHEN DONE WITH
						; REPLACING NUMBER.  THERE IS ONLY ONE TO REPLACE
						; FOR RENUM/THEN/ELSE
7E81	C3 9B 7D	JP	7D9B		; REPLACE THE NUMBER IN THE LINE WITH NEW LINE NUMBER
---------------------------------------------------------------------
						; ** ROUTINE: ERL **
7E84	06 03		LD	B,03		; B = 3 (LOOP COUNTER)
7E86	D7		RST	10		; ROM ROUTINE 1D78: LOAD AND EXAMINE NEXT CHAR AFTER HL LOC
7E87	38 13		JR	C,13		; JUMP TO 7E9C (WE HAVE A DIGIT)
7E89	FE 00		CP	00		; 00 IS END OF LINE
7E8B	CA 3F 7D	JP	Z,7D3F		; JUMP TO 7D3F (END OF LINE SO LOOP TO THE NEXT LINE)
						; FOLLOWING AN ERL TOKEN, ALL WE CARE ABOUT WOULD BE
						; D4(>), D5(=), D6(<)
7E8E	FE D7		CP	D7		; D7 IS SGN
7E90	30 06		JR	NC,06		; JUMP TO 7E98 (TOKEN IS ABOVE D6(<))
7E92	FE D4		CP	D4		; D4 IS >
7E94	38 02		JR	C,02		; JUMP TO 7E98 (TOKEN IS BELOW D4(<))
7E96	10 EE		DJNZ	EE		; JUMP TO 7E86 TO KEEP PROCESSING THIS ERL
7E98	2B		DEC	HL		; REWIND HL 1 BYTE
7E99	C3 54 7D	JP	7D54		; JUMP TO 7D54 (NOTHING ELSE TO DO FOR ERL SO LOOP TO NEXT LINE)
7E9C	FD 21 54 7D	LD	IY,7D54		; WILL RETURN TO CONTINUE PROCESSING WHEN DONE WITH
						; REPLACING NUMBER.  THERE IS ONLY ONE TO REPLACE
7EA0	C3 9B 7D	JP	7D9B		; REPLACE THE NUMBER IN THE LINE WITH NEW LINE NUMBER
---------------------------------------------------------------------
						; FINAL STEPS!
7EA3	2A C8 7F	LD	HL,(7FC8)	; DONE RENUMBERING.  HL = END OF PGM
7EA6	AF		XOR	A		; \
7EA7	77		LD	(HL),A		;  | WRITING THE 00 AT THE END OF PGM
7EA8	23		INC	HL		;  |
7EA9	77		LD	(HL),A		; /
7EAA	11 E9 42	LD	DE,42E9		; 42E9 IS START OF USER RAM FOR PROGRAM STORAGE
7EAD	2F		CPL			; A = FF.  AND WRITE FF TO FIRST BYTE. THIS IS JUST
7EAE	12		LD	(DE),A		; SO 1AFC DOESN'T GET 00 00 AT START AND QUIT EARLY.
7EAF	CD FC 1A	CALL	1AFC		; 1AFC IS UPDATE LINE POINTERS FOR ALL LINES AFTER NEW LINE
7EB2	23		INC	HL		; HL ENDS UP POINTING TO THE 00 00 AT END OF PGM
7EB3	23		INC	HL		; HL NOW POINTS 1 BYTE AFTER THE 00 00
7EB4	22 F9 40	LD	(40F9), HL	; POPULATE 40F9 (SHOULD POINT 1 BYTE AFTER 00 00)
7EB7	CD 61 1B	CALL	1B61		; ROM ROUTINE 1B61 IS MIDDLE OF THE "NEW" ROUTINE ...
						; (SEE BELOW FOR A DISASSEMBLY/EXPLANATION OF THIS ROUTINE)
7EBA	C3 19 1A	JP	1A19		; ROM ROUTINE 1A19: RETURN TO BASIC AND DISPLAY READY PROMPT
---------------------------------------------------------------------
7EBD	E1		POP	HL		; ** ROUTINE: ILLEGAL FC **
7EBE	21 B5 7F	LD	HL,7FB5		; "ILLEGAL<SPACE>FC<CR>"
7EC1	06 0B		LD	B,0B		; 11 CHARS
7EC3	CD 32 7F	CALL	7F32		; PRINT THE ERROR MSG
7EC6	18 EF		JR	EF		; JUMP TO 7EB7 TO EXIT
---------------------------------------------------------------------
7EC8	21 CC 7F	LD	HL,7FCC		; ** ROUTINE: INPUT **
						; READS UP TO 5 DIGITS PLUS <CR> INTO 7FCC-7FD1
						; ALLOWS ONLY DIGITS 0-9, BACKSPACE, AND ENTER
						; EVERYTHING ELSE IGNORED.  RETURNS ON ENTER.
7ECB	06 00		LD	B,0		; B KEEPS TRACK OF NUM DIGITS ENTERED
7ECD	CD 3A 7F	CALL	7F3A		; READ A KEY INTO A
7ED0	28 FB		JR	Z,FB		; JUMP TO 7ECD IF NOTHING READ (READ AGAIN)
7ED2	FE 01		CP	01		; 01 IS THE BREAK KEY; HITTING BREAK RESTARTS THE PROGRAM
7ED4	CA 4C 7C	JP	Z,7C4C		; JUMP TO START OF PROGRAM IF BREAK HIT
7ED7	FE 0D		CP	0D		; 0D IS ENTER
7ED9	28 27		JR	Z,27		; JUMP TO 7F02 IF ENTER HIT
7EDB	FE 08		CP	08		; 08 IS BACKSPACE
7EDD	28 16		JR	Z,16		; JUMP TO 7EF5 IF BACKSPACE HIT
7EDF	FE 30		CP	30		; 30 IS A 0
7EE1	38 EA		JR	C,EA		; JUMP TO 7ECD IF THEY ENTERED A KEY BELOW 0 (READ AGAIN)
7EE3	FE 3A		CP	3A		; 3E IS : (ONE ABOVE 9)
7EE5	30 E6		JR	NC,E6		; JUMP TO 7ECD IF THEY ENTERED A KEY ABOVE 9 (READ AGAIN)
7EE7	77		LD	(HL),A		; SAVE ENTERED DIGIT TO INPUT BUFFER
7EE8	3E 05		LD	A,05		; A = 5
7EEA	B8		CP	B		; ALREADY 5 DIGITS ENTERED?
7EEB	28 E0		JR	Z,E0		; JUMP TO 7ECD IF SO (READ AGAIN)
7EED	7E		LD	A,(HL)		; A = DIGIT ENTERED
7EEE	CD 45 7F	CALL	7F45		; PRINT CHAR IN A
7EF1	23		INC	HL		; NEXT SPOT IN INPUT BUFFER
7EF2	04		INC	B		; INCREMENT NUM DIGITS ENTERED
7EF3	18 D8		JR	D8		; JUMP TO 7ECD (READ AGAIN)
7EF5	AF		XOR	A		; ** BACKSPACE **
7EF6	B8		CP	B		; ANYTHING ENTERED YET
7EF7	28 D4		JR	Z,D4		; JUMP TO 7ECD IF NOT (READ AGAIN)
7EF9	3E 08		LD	A,08		; 08 IS BACKSPACE
7EFB	CD 45 7F	CALL	7F45		; PRINT CHAR IN A (THE BACKSPACE)
7EFE	2B		DEC	HL		; PREVIOUS SPOT IN INPUT BUFFER
7EFF	05		DEC	B		; DECREMENT NUM DIGITS ENTERED
7F00	18 CB		JR	CB		; JUMP TO 7ECD (READ AGAIN)
7F02	77		LD	(HL),A		; ** ENTER **
7F03	CD 45 7F	CALL	7F45		; NOTE WE PUT THE ENTER INTO THE BUFFER.  PRINT CHAR IN A
7F06	C9		RET
---------------------------------------------------------------------
7F07	11 00 00	LD	DE,00		; ** ROUTINE: SET DE = VALUE IN INPUT BUFFER **
						; HL START AT 1 BYTE BEFORE INPUT BUFFER.  THE INPUT
						; ROUTINE (7EC8) TERMINATES BUFFER WITH A 0D
7F0A	43		LD	B,E		; DE = 0, B = 0
7F0B	D7		RST	10		; ROM ROUTINE 1D78: LOAD AND EXAMINE NEXT CHAR AFTER HL LOC
7F0C	D0		RET	NC		; RETURN IF NOT A DIGIT (1D78 SETS C FOR DIGITS)
7F0D	E6 0F		AND	0F		; A = DIGIT VALUE NOW
7F0F	4F		LD	C,A		; C = A
7F10	E5		PUSH	HL		; SAVE HL
7F11	21 98 19	LD	HL,1998		; HL = 6552 DECIMAL.  SINCE WE READ A DIGIT, WE
						; ARE GOING TO CHECK IF DE > 6552 ALREADY.  NOTE
						; 65529 IS THE LARGEST LINE NUMBER ALLOWED
7F14	DF		RST	18		; ROM ROUTINE 1C90: COMPARE DE:HL, SET C IF DE>HL, Z IF EQUAL
7F15	DC 23 7F	CALL	C,7F23		; ERROR - SET BIT 0 OF FLAG BYTE
7F18	D5		PUSH	DE		; SAVE DE
7F19	E1		POP	HL		; HL = DE
7F1A	19		ADD	HL,DE		; HL = 2 * DE
7F1B	29		ADD	HL,HL		; HL = 4 * DE
7F1C	19		ADD	HL,DE		; HL = 5 * DE
7F1D	29		ADD	HL,HL		; HL = 10 * DE
7F1E	09		AD	HL,BC		; HL = HL + DIGIT = VALUE SO FAR
7F1F	EB		EX	DE.HL		; DE = VALUE SO FAR
7F20	E1		POP	HL		; RESTORE HL (POINTER INTO INPUT BUFFER)
7F21	18 E8		JR	E8		; JUMP TO 7F0B TO GET NEXT DIGIT
---------------------------------------------------------------------
7F23	DD CB 00 C6	SET	0,(IX+00)	; ** ROUTINE: ERROR **
7F27	C9		RET			; SETS BIT 0 OF THE FLAG BYTE (7FC7)
---------------------------------------------------------------------
7F28	7E		LD	A,(HL)		; ** ROUTINE: FIND NEXT LINE AFTER HL **
						; INPUT:
						;  HL - LOC OF CURRENT LINE
						;  DE - NEW LINE NUMBER OF CURRENT LINE (USUALLY)
						; OUTPUT:
						;  DE - ADDRESS OF NEXT LINE
						;  HL - WHATEVER DE WAS
						;  Z - IF THE NEXT LINE IS END OF PGM
7F29	23		INC	HL		; A = LSB OF NEXT LINE LOC
7F2A	66		LD	H,(HL)		; H = MSB OF NEXT LINE LOC
7F2B	6F		LD	L,A		; HL = ADDRESS OF NEXT LINE
7F2C	7E		LD	A,(HL)
7F2D	23		INC	HL
7F2E	B6		OR	(HL)		; CHECKING TO SEE IF NEXT LINE IS END OF PGM
7F2F	2B		DEC	HL		; HL = ADDRESS OF NEXT LINE
7F30	EB		EX	DE,HL		; DE = ADDRESS OF NEXT LINE, HL = NEW LINE NUMBER OF CURRENT
7F31	C9		RET			; LINE (USUALLY)
---------------------------------------------------------------------
7F32	7E		LD	A,(HL)		; ** ROUTINE: PRINT STRING AT HL FOR B CHARS ***
7F33	CD 45 7F	CALL	7F45		; PRINT CHAR IN A
7F36	23		INC	HL		; NEXT CHAR
7F37	10 F9		DJNZ	F9		: JUMP TO 7F32 IF MORE CHARS TO PRINT
7F39	C9		RET
---------------------------------------------------------------------
7F3A	D5		PUSH	DE		; ** ROUTINE: READ A KEY INTO A ***
7F3B	FD E5		PUSH	IY		; SAVE DE AND IY TO STACK, SINCE ROM ROUTINE OVERWRITES
7F3D	CD 2B 00	CALL	002B		; ROM ROUTINE 002B: READS KEY INTO A
7F40	B7		OR	A		; DOING AN OR TO SEE IF ANYTHING READ
7F41	FD E1		POP	IY		; RESTORE IY AND DE
7F43	D1		POP	DE
7F44	C9		RET
---------------------------------------------------------------------
7F45	D5		PUSH	DE		; ** ROUTINE: PRINT CHAR IN A **
7F46	FD E5		PUSH	IY		; SAVE DE AND IY TO STACK, SINCE ROM ROUTINE OVERWRITES
7F48	CD 33 00	CALL	0033		; ROM ROUTINE 0033: DISPLAY CHAR
7F4B	FD E1		POP	IY		; NOTE: E1 IS FROM THE FIRST BYTE OF BLOCK 4

AB			CHECKSUM FOR THIRD DATA BLOCK

=====================================================================

3C			DATA HEADER
7B			COUNT BYTE (7B = 123 BYTES)
4C 7F			LOAD ADDRESS (7F4C = 32588)

FOURTH DATA BLOCK (123 BYTES)
SHOWING LOCATION IN MEMORY WHERE LOADED.

E1			FIRST BYTE OF FOURTH BLOCK, PUT INTO POP COMMAND ABOVE

7F4D	D1		POP	DE		; RESTORE IY AND DE FROM STACK
7F4E	C9		RET
---------------------------------------------------------------------
7F4F	21 CC 7F	LD	HL,7FCC		; ** ROUTINE: CONVERT TO DECIMAL **
						; THIS CONVERTS THE VALUE IN DE TO
						; ITS BCD REPRESENTATION AND SAVES
						; THAT IN 7FCC-7FCE.  THEN THIS IS
						; USED TO CONVERT TO DECIMAL WHICH IS
						; SAVED IN 7FCF-7FD3
						;
						; FIRST STEP IS TO SET THE BCD
						; VALUE TO 0 0 0 0 0 0.
						; 7FCC-7FCE SET TO 00 00 00
						;
7F52	06 03		LD	B,03		; LOOP COUNTER
7F54	36 00		LD	(HL),00		; SAVE 0 TO MEMORY
7F56	23		INC	HL		; NEXT BYTE IN MEMORY
7F57	10 FB		DJNZ	FB		; JUMP TO 7F54 (LOOP)
						;
7F59	06 10		LD	B,10		; OUTER LOOP COUNTER = 16 BITS
7F5B	C5		PUSH	BC		; SAVE OUTER LOOP COUNTER
						;
						; NOW MULTIPLY DE BY 2, SHIFTING
						; THE HIGH BIT INTO THE CARRY FLAG
7F5C	CB 23		SLA	E		;
7F5E	CB 12		RL	D		; DE = DE * 2.  C FLAG = HIGH BIT OF DE
						;
						; AND THEN APPLY THAT BIT TO THE BCD
						; VALUE IN 7FCC-7FCE BY MULTIPLYING THROUGH
						; BY 2 AND KEEPING THESE 3 BYTES IN BCD FORMAT
						;
7F60	21 CC 7F	LD	HL,7FCC		; 7FCC-7FCE IS BCD VALUE
7F63	06 03		LD	B,03		; INNER LOOP COUNTER = 3.  3 BYTES
7F65	7E		LD	A,(HL)		; A = CURRENT VALUE
7F66	8F		ADC	A,A		; A = A*2 + CARRY
7F67	27		DAA			; CONVERT A TO BCD
						; THIS ENSURE EACH NIBBLE IS 0-9 AND
						; ALSO WILL SET THE CARRY FLAG IF WE
						; NEED TO CARRY INTO THE NEXT BYTE
7F68	77		LD	(HL),A		; SAVE A TO MEMORY
7F69	23		INC	HL		; NEXT BYTE IN BCD MEMORY
7F6A	10 F9		DJNZ	F9		; JUMP TO 7F65 (INNER LOOP)
7F6C	C1		POP	BC		; RESTORE OUTER LOOP COUNTER
7F6D	10 EC		DJNZ	EC		; JUMP TO 7F5B (OUTER LOOP)
						;
						; AT THIS POINT 7FCC-7FCE HOLDS THE BCD
						; REPRESENTATION, IN REVERSE DIGIT ORDER.
						; FOR EXAMPLE, FOR DE=3039H (12345 DECIMAL)
						; 7FCC 7FCD 7FCE
						; 4 5  2 3  0 1
						; H L  H L  H L  (HIGH AND LOW NIBBLES)
						;
						; NOW WE WILL CONVERT THIS TO DECIMAL
						;
7F6F	11 CE 7F	LD	DE,7FCE		; DE = LOC TO WRITE DECIMAL DIGITS
7F72	21 CE 7F	LD	HL,7FCE		; HL = END OF BCD BUFFER
7F75	06 03		LD	B,03		; 3 BYTES TO LOOP THROUGH
7F77	3E 33		LD	A,33		; NOTE THAT "3" IS FIRST HEX DIGIT FOR 0-9
7F79	ED 67		RRD			; RRD IS A ROTATE RIGHT AMONG THE VALUES IN
						; A AND (HL) AS FOLLOWS.  IF A=WX AND (HL)=YZ
						; THE RESULT WILL BE A=WZ AND (HL)=XY
						; THE HIGH NIBBLE OF A IS UNTOUCHED AND THE
						; OTHER 3 NIBBLES ROTATE RIGHT.
						; TAKING EXAMPLE ABOVE A=33 (HL)=01
						; AFTER ROTATE RIGHT: A=31 (HL)=30
						; NOTICE THESE ARE THE VALUES FOR 1 AND 0
7F7B	08		EX	AF,AF'		; SAVING A OVER TO A'
7F7C	7E		LD	A,(HL)		; A = FIRST DIGIT (30 IN ABOVE EXAMPLE)
7F7D	12		LD	(DE),A		: SAVE FIRST DIGIT TO MEMORY
7F7E	08		EX	AF,AF'		; RESTORE A FROM A'
7F7F	13		INC	DE		; BUMP DE TO NEXT POSITION IN MEMORY
7F80	12		LD	(DE),A		; AND SAVE A TO MEMORY (31 IN ABOVE EXAMPLE)
7F81	2B		DEC	HL		; STEP BACK 1 BYTE IN BCD BUFFER
7F82	13		INC	DE		; BUMP DE TO NEXT POSITION IN MEMORY
7F83	10 F2		DJNZ	F2		; JUMP TO 7F77 (LOOP THROUGH 3 BCD BYTES)
7F85	C9		RET			; NOTICE THIS THIS OVERWRITES THE LAST BYTE
						; OF THE BCD BUFFER.  AND IT WILL BE A 30.
						; A 2 BYTE INT WILL BE NO MORE THAN 5 DIGITS, SO
						; THAT 6TH (FIRST) DIGIT WILL ALWAYS BE A 0.
						; THIS CLEVERNESS SAVES ONE BYTE IN MEMORY!
---------------------------------------------------------------------
7F86	11 CF 7F	LD	DE,7FCF		; ** ROUTINE: FIND NON 0 DECIMAL DIGIT **
						; THIS ROUTINE LOOKS AT THE 7FCF-7FD3
						; MEMORY, WHICH WILL HOLD 5 DECIMAL DIGITS
						; FROM ROUTINE 7F4F'S WORK.  IT WILL POSITION
						; DE TO THE FIRST NON 0 DIGIT IN THAT
						; BUFFER. IT WILL ALSO SET B TO THE NUMBER
						; OF REMAINING DIGITS.
7F89	06 05		LD	B,05		; UP TO 5 DIGITS
7F8B	1A		LD	A,(DE)		; LOAD A WITH CURRENT DIGIT
7F8C	FE 30		CP	30		; COMPARE A TO CHAR 0
7F8E	C0		RET	NZ		; RETURN IF NOT A 0 (WE ARE SKIPPING 0S)
7F8F	13		INC	DE		; GOTO NEXT DIGIT
7F90	10 F9		DJNZ	F9		; JUMP TO 7F8B IF MORE DIGITS
7F92	1B		DEC	DE		; IF WE MADE IT HERE, IT WAS 00000
7F93	06 01		LD	B,01		; SO JUST HAVE ONE DIGIT (A 0)
7F95	C9		RET
---------------------------------------------------------------------
7F96	CD 4F 7F	CALL	7F4F		; ** ROUTINE: PRINT DE IN DECIMAL **
						; 7F4F IS FIRST CALLED TO POPULATE
						; 7FCF-7FD3 WITH THE DECIMAL DIGITS FOR
						; THE VALUE IN DE.  THEN 7F86 IS CALLED TO
						; POSITION DE TO THE FIRST NON 0 DIGIT IN
						; THAT BUFFER (OR THE LAST DIGIT IF IT WAS
						; ALL 0S) AND B IS SET TO THE NUMBER OF
						; DIGITS TO PRINT.  THEN 7F32 IS CALLED
						; TO PRINT THE NUMBER.
						;
7F99	CD 86 7F	CALL	7F86		; NOW DE POINTS TO NUMBER, B IS NUM DIGITS
7F9C	EB		EX	DE,HL		; HL POINTS TO NUMBER
7F9D	CD 32 7F	CALL	7F32		; PRINT THE DECIMAL NUMBER
7FA0	C9		RET
---------------------------------------------------------------------


REMAINDER OF DATA BLOCK ARE STRINGS CONSTANTS:

7FA1	0E 0D 52 45 4E 55 4D 0D 4F 4C 23 3D	; <CURON><CR>RENUM<CR>OL#=  \  PROMPTS FOR
7FAD	4E 4C 23 3D				; NL#=                       | USER INPUT
7FB1	49 4E 43 3D				; INC=                      /
7FB5	49 4C 4C 45 47 41 4C 20 46 43 0D	; ILLEGAL<SPACE>FC<CR>      \
7FC0	55 4C 20				; UL<SPACE>                  | ERROR MSGS
7FC3    20 49 4E 20				; <SPACE>IN<SPACE>          /

51			CHECKSUM FOR FOURTH DATA BLOCK

=====================================================================

78			ENTRY HEADER
4C 7C			ENTRY ADDRESS (7C4C = 31820)

=====================================================================


MEMORY LOCATIONS USED BY RENUM PROGRAM
(SOME ARE USED FOR MULTIPLE PURPOSES)

7FC7      FLAG BYTE
          BIT 0: SET BY 7F07:** ROUTINE: SET DE = VALUE IN INPUT BUFFER **
                 (ACTUALLY BY 7F23, WHICH 7F07 CALLS)
                 WHEN VALUE IS > 65529.  FOR EXAMPLE WHEN PARSING THE USER
                 INPUT FOR OL#,NC#,INC AND WHEN PARSING A LINE NUMBER FROM
                 A LINE OF BASIC PGM
          BIT 1: DURING PASS 2 (RENUMBERING) IGNORE 0S IF BIT = 1
7FC8-7FC9 KEEPS TRACK OF THE END OF THE PGM.  IE POINTS TO THE 00 00
7FCA-7FCB NL# (USER INPUT)
          DURING PASS 2 IT IS USED AS WORKSPACE FOR EACH LINE'S NEW LINE NUMBER
7FCC-7FD1 INPUT BUFFER 5 DIGITS AND 1 EXTRA FOR <CR>
7FD2-7FD3 INC (USER INPUT)
7FD4-7FD5 OL# (USER INPUT)
7FD6-7FFE STACK

ROUTINE 7F4F (CONVERT TO DECIMAL) USES 8 BYTES TO CONVERT A 2 BYTE VALUE TO DECIMAL:
7FCC-7FCE USED FOR BCD REPRESENTATION OF A 2 BYTE VALUE
7FCF-7FD3 USED FOR DECIMAL REPRESENTATION OF A 2 BYTE VALUE

ROUTINE 7D9B (REPLACE OLD NUMBER WITH NEW NUMBER) USES 2 BYTES:
7FD4-7FD5 LOC IN LINE TO PICK UP AFTER AFTER WE REPLACED AN OLD NUMBER WITH NEW


=====================================================================

ROM ROUTINE 1D78: LOAD AND EXAMINE NEXT CHAR AFTER HL LOC

THIS ROUTINE WILL LOAD THE NEXT CHARACTER INTO THE A REGISTER
AND SET FLAGS.  IT STARTS LOOKING 1 BYTE AFTER WHEREVER HL
IS POINTING.  IT IS RATHER SHORT (25 BYTES).

FIRST, A DISASSEMBLY OF THE ROUTINE:

1D78	23		INC	HL		; BUMP HL TO NEXT CHAR
1D79	7E		LD	A,(HL)		; AND LOAD CHAR INTO A
1D7A	FE 3A		CP	3A		; COMPARE A TO :
1D7C	D0		RET	NC		; IF A IS >= : WE RETURN
1D7D	FE 20		CP	20		; COMPARE A TO <SP>
1D7F	CA 78 1D	JP	Z,1D78		; IF A SPACE, IGNORE AND READ AGAIN
1D82	FE 0B		CP	0B		; COMPARE TO <VT> (0B)
1D84	30 05		JR	NC,05		; JUMP IF >= <VT>.  NOT A CTRL CHAR
1D86	FE 09		CP	09		; COMPARE TO <HT> (09)
1D88	D2 78 1D	JP	NC, 1D78	; IF <HT> OR <LF>, IGNORE AND READ AGAIN
1D8B	FE 30		CP	30		; COMPARE TO 0
1D8D	3F		CCF			; AND INVERT THE CARRY FLAG
1D8E	3C		INC	A		;
1D8F	3D		DEC	A		; SET FLAGS EXCEPT FOR C
1D90	C9		RET			; RETURN

AFTER RETURN, A WILL HOLD THE NEXT CHAR, AND HL WILL BE POINTING TO IT.
THE C AND Z FLAGS ARE ALSO PART OF THE RETURN INFORMATION OF INTEREST.

IN SUMMARY, WE CAN DOCUMENT THE BEHAVIOR AS FOLLOWS BASED ON THE NEXT CHAR:

<NULL>         (00)		NC, Z
<BREAK>-<BKSP> (01-08)		NC, NZ
<HT>           (09)		SKIPPED OVER AND IT GOES TO THE NEXT CHAR
<LF>           (0A)		SKIPPED OVER AND IT GOES TO THE NEXT CHAR
<VT>-<EREOF>   (0B-1F)		NC, NZ
<SP>           (20)		SKIPPED OVER AND IT GOES TO THE NEXT CHAR
!-/            (21-2F)		NC, NZ
0-9            (30-39)		C,  NZ
:              (3A)		NC, Z
ABOVE :        (3B-FF)		NC, NZ

ONE THING WE NOTICE IS THE CALLER CAN THEN CHECK THE C FLAG.  IF IT IS
SET, THEN WE KNOW A WILL HOLD A DIGIT.  THE Z FLAG SHOULD BE SET ONLY
IF THE NEXT CHAR WAS <NULL> (00) OR A : (3A).


WE CAN WRITE A PROGRAM IN BASIC TO VALIDATE THE ABOVE ANALYSIS.
THIS PROGRAM USES A SMALL ASSEMBLY ROUTINE TO CALL THE 1D78 ROM ROUTINE.

10 DEFINT A-Z : H$ = "0123456789ABCDEF"
20 Y$=" * " : REM FIRST 3 BYTES WILL BE FOR MEMORY AND REST WILL BE ASM PGM
30 REM BYTE 1 IS WHERE WE WILL STORE THE CHAR
40 REM BYTE 2 IS A STOPPER CHAR * SO THAT ROM ROUTINE WILL RETURN * FOR SKIPPED CHAR
50 REM BYTE 3 IS WHERE WE WILL CAPTURE THE FLAGS REGISTER F
60 ON ERROR GOTO 3000
70 READ A : Y$ = Y$ + CHR$(A) : GOTO 70
80 X = PEEK(VARPTR(Y$)+1) + 256*PEEK(VARPTR(Y$)+2) : REM ADDRESS OF Y$
90 POKE X+4,X AND255:POKE X+5,X/256 : REM VALUE OF XXXX FOR LD HL,XXXX
100 POKE 16526,(X+3)AND255 : REM ASM PGM STARTS AT 4TH BYTE OF Y$
110 POKE 16527,(X+3)/256
120 FOR I = 0 TO 255
130 POKE X,I : REM SAVING THE CHAR TO 1ST BYTE OF Y$
140 U=USR(0) : REM RUN THE ASM PGM
150 A = PEEK(X) : REM RETURNED CHAR
160 F = PEEK(X+2) : REM FLAGS REGISTER
170 C = F AND 1	: REM CARRY FLAG
180 Z = (F AND 64)/64 : REM ZERO FLAG
190 GOSUB 1000
200 NEXT I
210 END
1000 REM PRINT RESULT
1010 H=I : GOSUB 2000
1020 H=A : GOSUB 2000
1030 IF C = 1 PRINT "C  "; ELSE PRINT "NC ";
1040 IF Z = 1 PRINT "Z" ELSE PRINT "NZ"
1050 RETURN
2000 REM PRINT H IN HEX AND AS A CHAR
2010 PRINT MID$(H$,H/16+1,1);MID$(H$,(H AND15)+1,1);
2020 IF H>31 AND H<127 PRINT "(";CHR$(H);") "; ELSE PRINT "    ";
2030 RETURN
3000 REM ERROR HANDLER
3010 IF ERR/2+1=4 RESUME 80 : REM OUT OF DATA
3020 PRINT "ERROR: ERR=";ERR;", ERL=";ERL
3030 STOP
4000 REM ASM PGM STARTING WITH "LD HL,XXXX"
4010 DATA 33,0,0,229,43,205,120,29,225,119,197,245,193,35,35,113,193,201

ASSEMBLY PROGRAM IS:

21 XX XX	LD	HL, XXXX	; LOAD HL WITH ADDRESS OF Y$.  XXXX GETS FILLED IN BY BASIC
E5		PUSH	HL		; SAVE HL
2B		DEC	HL		; MOVE HL 1 BYTE BACKWARDS
CD 78 1D	CALL	1D78		; CALL THE ROM ROUTINE
E1		POP	HL		; HL = ADDRESS OF Y$
77		LD	(HL),A		; SAVE READ CHAR TO 1ST BYTE OF Y$
C5		PUSH	BC		; SAVE BC
F5		PUSH	AF		; SAVE CONTENTS OF A AND F (FLAGS) TO STACK
C1		POP	BC		; NOW C = SAVED F REGISTER
23		INC	HL
23		INC	HL		; POINT HL TO 3RD BYTE OF Y$
71		LD	(HL),C		; SAVE THE FLAGS REGISTER TO 3RD BYTE OF Y$
C1		POP	BC		; RESTORE VALUE OF BC
C9		RET			; RETURN

WHY DO WE NEED THE "PUSH HL"?  REMEMBER THAT THE ROUTINE SKIPS OVER
CERTAIN CHARACTERS, SUCH AS <SP>.  SO HL ENDS UP POINTING TO THE FINAL
READ CHARACTER, WHICH WILL NOT NECESSARILY BE THE 1ST BYTE OF Y$.

THE FLAGS REGISTER:

7TH BIT: SIGNED FLAG (S). DETERMINES WHETHER THE ACCUMULATOR ENDED UP POSITIVE (1),
         OR NEGATIVE (0). THIS FLAG ASSUMES THAT THE ACCUMULATOR IS SIGNED.
6TH BIT: ZERO FLAG (Z). DETERMINES WHETHER THE ACCUMULATOR IS ZERO OR NOT.
5TH BIT: THE 5TH BIT OF THE LAST 8-BIT INSTRUCTION THAT ALTERED FLAGS.
4TH BIT: HALF-CARRY (H). IS SET WHEN THE LEAST-SIGNIFICANT NIBBLE OVERFLOWS.
3TH BIT: THE 3RD BIT OF THE LAST 8-BIT INSTRUCTION THAT ALTERED FLAGS.
2ND BIT: PARITY/OVERFLOW (P/V). EITHER HOLDS THE RESULTS OF PARITY OR OVERFLOW. ITS
         VALUE DEPENDS ON THE INSTRUCTION USED. IS USED FOR SIGNED INTEGERS.
1ST BIT: ADD/SUBTRACT (N). DETERMINES WHAT THE LAST INSTRUCTION USED ON THE
         ACCUMULATOR WAS. IF IT WAS ADD, THE BIT IS RESET (0). IF IT WAS SUBTRACT,
         THE BIT IS SET (1).
0TH BIT: CARRY (C). DETERMINES IF THERE WAS AN OVERFLOW OR NOT. NOTE THAT IT CHECKS
         FOR UNSIGNED VALUES. THE CARRY FLAG IS ALSO SET IF A SUBTRACTION RESULTS
         IN A NEGATIVE

=====================================================================

DISASSEMBLY AND EXPLANATION OF 1B61

1B61 IS IN THE MIDDLE OF THE NEW ROUTINE, WHICH STARTS AT 1B49.  THE INITIAL CODE FROM
1B49 - 1B60 IS NOT NEEDED FOR THE PURPOSES OF THE RENUM PROGRAM.  IT DOES THINGS LIKE
CLEAR THE SCREEN, TURN TRACE OFF, CLEAR THE AUTO INCREMENT FLAG.  IN PARTICULAR IT
SETS THE FIRST TWO BYTES OF THE PGM TO 00 00, WHICH WE DEFINITELY DO NOT WANT TO BE DONE.

THE REST OF THE ROUTINE INITIALIZES VARIOUS POINTERS USED BY BASIC AND CLEARS VARIOUS
FLAGS USED BY BASIC.  IT WRAPS UP BY TURNING OFF THE CASSETTE TAPE DRIVE AND SETTING
THE OUTPUT TO VIDEO.

THEN IT RETURNS TO THE CALLER, WHICH IN OUR CASE WILL BE THE RENUM PROGRAM

							; 1B61 - LANDING HERE FROM RENUM PROGRAM
							; HL COMES IN POINTING TO 1 BYTE PAST END
							; OF PGM.  (1 BYTE AFTER THE 00 00.)
							; NOTE (40F9) POINTS HERE TOO.

1B61	22 DF 40	LD	(40DF), HL		; 40DF IS ENTRY POINT FOR SYSTEM TAPES WE ARE
							; USING IT AS A STORAGE FOR WHATEVER HL IS.
1B64	06 1A		LD	B, 1A			; B = 26
1B69	36 04		LF	(HL), 04		; WRITING 26 <EOT> AFTER END OF PGM
							; NOTE 04 IS DESCRIPTOR CODE FOR SINGLE
							; PRECISION INT
1B6B	23		INC	HL
1B6C	10 FB		DJNZ	FB			; JUMP TO 1B69 (LOOP)
1B6E	AF		XOR	A			; A = 0
1B6F	32 F2 40	LD	(40F2), A		; CLEARING ERROR FLAG THAT IS USED BY "RESUME"
1B72	6F		LD	L, A
1B73	67		LD	H, A			; HL = 0
1B74	22 F0 40	LD	(40F0), HL		; CLEAR THE "ON ERROR" ADDRESS
1B77	22 F7 40	LD	(40F7), HL		; CLEAR ADDRESS FOR NEXT STATEMENT THAT WOULD BE
							; USED FOR "CONT" AFTER A BREAK, STOP, END
1B7A	2A B1 40	LD	HL, (40B1)		; HL = HIGHEST ADDRESS AVAILABLE FOR STRINGS
							; (SET BY MEMSIZE AT BOOT TIME)
1B7D	22 D6 40	LD	(40D6), HL		; SET STRING WORK AREA POINTER
1B80	CD 91 1D	CALL	1D91			; BASIC "RESTORE" STATEMENT - RESETS DATA STATEMENT
							; READ LOCATION
1B83	2A F9 40	LD	HL, (40F9)		; HL = 1 BYTE PAST END OF PGM
1B86	22 FB 40	LD	(40FB), HL		; SET START OF SIMPLE VARIABLES
1B89	22 FD 40	LD	(40FD), HL		; SET END OF SIMPLE VARIABLES
1B8C	CD BB 41	CALL	41BB			; ALLOW DISK BASIC TO CLOSE ANY OPEN FILES
1B8F	C1		POP	BC			; BC = RETURN ADDRESS (THIS WILL BE 7EBA SINCE WE
							; WERE CALLED FROM THE FINAL STEPS IN RENUM)
1B90	2A A0 40	LD	HL, (40A0)		; HL = START OF STRING STORAGE
1B93	2B		DEC	HL
1B94	2B		DEC	HL			; HL = 2 BYTES BEFORE START OF STRING STORAGE
1B95	22 E8 40	LD	(40E8), HL		; SET BASIC'S STACK LOCATION
1B98	23		INC	HL
1B99	23		INC	HL			; HL = START OF STRING STORAGE
1B9A	F9		LD	SP, HL			; SET SYSTEM STACK TO START OF STRING STORAGE
1B9B	21 B5 40	LD	HL, 40B5		; HL = STRING WORK AREA
1B9E	22 B3 40	LD	(40B3), HL		; SET STRING WORK AREA POINTER TO THAT
1BA1	CD 8B 03	CALL	038B			; SET OUTPUT DEVICE TO VIDEO AND PRINT LINE PRINTER BUFFER
1BA4	CD 69 21	CALL	2169			; TURN OFF CASSETTE AND SET OUTPUT DEVICE TO VIDEO
1BA7	AF		XOR	A			; A = 0
1BA8	67		LD	H, A
1BA9	6F		LD	L, A			; HL = 0
1BAA	32 DC 40	LD	(40DC), A		; CLEARS THE "FOR" STATEMENT FLAG
1BAD	E5		PUSH	HL			; SIGNAL "RUN" PUSH
1BAC	C5		PUSH	BC			; SAVE ORIGINAL RETURN ADDRESS TO STACK
1BAF	2A DF 40	LD	HL, (40DF)		; RESTORE HL TO ORIGINAL VALUE
1BB2	C9		RET

=====================================================================

HEX DUMP OF RENUM-16.CAS

00000000  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000020  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000030  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000040  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000050  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000060  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000070  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000080  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000090  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000000A0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000000B0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000000C0  00 00 00 00 00 00 00 00  A5 55 52 45 4E 55 4D 20  |.........URENUM |
000000D0  3C 00 4C 7C 31 FE 7F 21  A1 7F 06 0C CD 32 7F CD  |<.L|1..!.....2..|
000000E0  C8 7E DD 21 C7 7F DD CB  00 86 AF 57 5F B8 21 CB  |.~.!.......W_.!.|
000000F0  7F C4 07 7F ED 53 D4 7F  21 AD 7F 06 04 CD 32 7F  |.....S..!.....2.|
00000100  CD C8 7E AF 11 0A 00 B8  21 CB 7F C4 07 7F ED 53  |..~.....!......S|
00000110  CA 7F 21 B1 7F 06 04 CD  32 7F CD C8 7E 11 0A 00  |..!.....2...~...|
00000120  21 CB 7F AF B8 C4 07 7F  ED 53 D2 7F 2A E9 42 7C  |!........S..*.B||
00000130  B5 CA B7 7E 7A B3 CA BE  7E DD CB 00 46 C2 BE 7E  |...~z...~...F..~|
00000140  11 FA FF CD 2C 1B ED 43  C8 7F ED 5B D4 7F CD 2C  |....,..C...[...,|
00000150  1B 38 03 CA BE 7E C5 ED  5B CA 7F CD 2C 1B C5 E1  |.8...~..[...,...|
00000160  D1 DF DA BE 7E EB E5 ED  4B D2 7F ED 5B CA 7F 18  |....~...K...[...|
00000170  0E 09 DA BD 7E EB E5 21  F9 FF DF E1 DA BD 7E CD  |....~..!......~.|
00000180  28 7F 20 ED D1 D5 21 E9  42 DF 28 15 E5 FD E1 CD  |(. ...!.B.(.....|
00000190  28 7F FD 7E 02 FD 77 00  FD 7E 03 FD 77 01 EB 18  |(..~..w..~..w...|
000001A0  E8 ED 5B CA 7F E1 E5 FD  E1 CD 28 7F FD 7E 02 FD  |..[.......(..~..|
000001B0  77 00 FD 7E 03 FD 77 01  FD 75 02 FD 74 03 28 04  |w..~..w..u..t.(.|
000001C0  09 EB 18 E2 21 E8 42 ED  5B C8 7F 1B DF CA A3 7E  |....!.B.[......~|
000001D0  23 23 23 7E 42 3C 00 4C  7D 32 CA 7F 23 7E 32 CB  |###~B<.L}2..#~2.|
000001E0  7F DD CB 00 8E D7 38 FD  20 06 FE 00 28 DE 18 F1  |......8. ...(...|
000001F0  FE 8D 28 22 FE 91 28 1E  FE C2 CA 84 7E FE 9F CA  |..("..(.....~...|
00000200  6D 7E FE CA CA 71 7E FE  95 CA 71 7E FE 9E 20 D5  |m~...q~...q~.. .|
00000210  DD CB 00 CE 18 CF D7 38  0B FE 00 28 AF FE 2C 28  |.......8...(..,(|
00000220  F5 2B 18 BD FD 21 89 7D  E5 2B DD CB 00 86 CD 07  |.+...!.}.+......|
00000230  7F E5 DD CB 00 46 C2 45  7E DD CB 00 4E 28 05 7A  |.....F.E~...N(.z|
00000240  B3 CA 68 7E 21 E7 42 D7  FE 00 20 FB D5 ED 5B C8  |..h~!.B... ...[.|
00000250  7F 1B DF D1 CA 45 7E 23  7E 23 E5 66 6F DF E1 23  |.....E~#~#.fo..#|
00000260  23 20 E4 56 2B 5E CD 4F  7F E1 C1 C5 E5 AF ED 42  |# .V+^.O.......B|
00000270  CD 86 7F 7D 90 38 34 28  1E E1 E5 4F AF 47 ED 42  |...}.84(...O.G.B|
00000280  EB E1 ED 53 D4 7F ED A0  D5 ED 5B C8 7F DF D1 20  |...S......[.... |
00000290  F5 ED 53 C8 7F 18 04 E1  22 D4 7F E1 CD 86 7F 1A  |..S.....".......|
000002A0  77 13 23 10 FA 2A D4 7F  2B FD E9 ED 44 06 00 4F  |w.#..*..+...D..O|
000002B0  2A C8 7F E5 D1 09 22 C8  7F EB C1 0B ED 43 D4 7F  |*....."......C..|
000002C0  ED A8 D5 ED 5B D4 7F DF  D1 20 F5 13 ED 53 D4 7F  |....[.... ...S..|
000002D0  18 C9 21 C0 7F 06 03 CD  32 7B 3C 00 4C 7E 7F DD  |..!.....2{<.L~..|
000002E0  CB 00 46 CC 96 7F 21 C3  7F 06 04 CD 32 7F ED 5B  |..F...!.....2..[|
000002F0  CA 7F CD 96 7F 3E 0D CD  45 7F E1 2B C1 FD E9 DD  |.....>..E..+....|
00000300  CB 00 CE D7 38 09 FE 00  CA 3F 7D 2B C3 54 7D FD  |....8....?}+.T}.|
00000310  21 54 7D C3 9B 7D 06 03  D7 38 13 FE 00 CA 3F 7D  |!T}..}...8....?}|
00000320  FE D7 30 06 FE D4 38 02  10 EE 2B C3 54 7D FD 21  |..0...8...+.T}.!|
00000330  54 7D C3 9B 7D 2A C8 7F  AF 77 23 77 11 E9 42 2F  |T}..}*...w#w..B/|
00000340  12 CD FC 1A 23 23 22 F9  40 CD 61 1B C3 19 1A E1  |....##".@.a.....|
00000350  21 B5 7F 06 0B CD 32 7F  18 EF 21 CC 7F 06 00 CD  |!.....2...!.....|
00000360  3A 7F 28 FB FE 01 CA 4C  7C FE 0D 28 27 FE 08 28  |:.(....L|..('..(|
00000370  16 FE 30 38 EA FE 3A 30  E6 77 3E 05 B8 28 E0 7E  |..08..:0.w>..(.~|
00000380  CD 45 7F 23 04 18 D8 AF  B8 28 D4 3E 08 CD 45 7F  |.E.#.....(.>..E.|
00000390  2B 05 18 CB 77 CD 45 7F  C9 11 00 00 43 D7 D0 E6  |+...w.E.....C...|
000003A0  0F 4F E5 21 98 19 DF DC  23 7F D5 E1 19 29 19 29  |.O.!....#....).)|
000003B0  09 EB E1 18 E8 DD CB 00  C6 C9 7E 23 66 6F 7E 23  |..........~#fo~#|
000003C0  B6 2B EB C9 7E CD 45 7F  23 10 F9 C9 D5 FD E5 CD  |.+..~.E.#.......|
000003D0  2B 00 B7 FD E1 D1 C9 D5  FD E5 CD 33 00 FD AB 3C  |+..........3...<|
000003E0  7B 4C 7F E1 D1 C9 21 CC  7F 06 03 36 00 23 10 FB  |{L....!....6.#..|
000003F0  06 10 C5 CB 23 CB 12 21  CC 7F 06 03 7E 8F 27 77  |....#..!....~.'w|
00000400  23 10 F9 C1 10 EC 11 CE  7F 21 CE 7F 06 03 3E 33  |#........!....>3|
00000410  ED 67 08 7E 12 08 13 12  2B 13 10 F2 C9 11 CF 7F  |.g.~....+.......|
00000420  06 05 1A FE 30 C0 13 10  F9 1B 06 01 C9 CD 4F 7F  |....0.........O.|
00000430  CD 86 7F EB CD 32 7F C9  0E 0D 52 45 4E 55 4D 0D  |.....2....RENUM.|
00000440  4F 4C 23 3D 4E 4C 23 3D  49 4E 43 3D 49 4C 4C 45  |OL#=NL#=INC=ILLE|
00000450  47 41 4C 20 46 43 0D 55  4C 20 20 49 4E 20 51 78  |GAL FC.UL  IN Qx|
00000460  4C 7C                                             |L||
00000462
